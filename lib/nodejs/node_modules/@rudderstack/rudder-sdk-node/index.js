"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");
var removeSlash = require("remove-trailing-slash");
var looselyValidate = require("@segment/loosely-validate-event");
var axios = require("axios");
var axiosRetry = require("axios-retry");
var ms = require("ms");
var uuid = require("uuid/v4");
var md5 = require("md5");
var isString = require("lodash.isstring");
var version = require("./package.json").version;

var setImmediate = global.setImmediate || process.nextTick.bind(process);
var noop = function noop() {};

var Analytics = function () {
  /**
   * Initialize a new `Analytics` with your Segment project's `writeKey` and an
   * optional dictionary of `options`.
   *
   * @param {String} writeKey
   * @param {Object} [options] (optional)
   *   @property {Number} flushAt (default: 20)
   *   @property {Number} flushInterval (default: 10000)
   *   @property {String} host (default: required)
   *   @property {Boolean} enable (default: true)
   */

  function Analytics(writeKey, dataPlaneURL, options) {
    _classCallCheck(this, Analytics);

    options = options || {};

    assert(writeKey, "You must pass your project's write key.");
    assert(dataPlaneURL, "You must pass your data plane url.");

    this.queue = [];
    this.writeKey = writeKey;
    this.host = removeSlash(dataPlaneURL);
    this.timeout = options.timeout || false;
    this.flushAt = Math.max(options.flushAt, 1) || 20;
    this.flushInterval = options.flushInterval || 10000;
    this.flushed = false;
    Object.defineProperty(this, "enable", {
      configurable: false,
      writable: false,
      enumerable: true,
      value: typeof options.enable === "boolean" ? options.enable : true
    });

    axiosRetry(axios, {
      retries: options.retryCount || 3,
      retryCondition: this._isErrorRetryable,
      retryDelay: axiosRetry.exponentialDelay
    });
  }

  _createClass(Analytics, [{
    key: "_validate",
    value: function _validate(message, type) {
      try {
        looselyValidate(message, type);
      } catch (e) {
        if (e.message === "Your message must be < 32kb.") {
          console.log("Your message must be < 32kb. This is currently surfaced as a warning to allow clients to update. Versions released after August 1, 2018 will throw an error instead. Please update your code before then.", message);
          return;
        }
        throw e;
      }
    }

    /**
     * Send an identify `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "identify",
    value: function identify(message, callback) {
      this._validate(message, "identify");
      this.enqueue("identify", message, callback);
      return this;
    }

    /**
     * Send a group `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "group",
    value: function group(message, callback) {
      this._validate(message, "group");
      this.enqueue("group", message, callback);
      return this;
    }

    /**
     * Send a track `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "track",
    value: function track(message, callback) {
      this._validate(message, "track");
      this.enqueue("track", message, callback);
      return this;
    }

    /**
     * Send a page `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "page",
    value: function page(message, callback) {
      this._validate(message, "page");
      this.enqueue("page", message, callback);
      return this;
    }

    /**
     * Send a screen `message`.
     *
     * @param {Object} message
     * @param {Function} fn (optional)
     * @return {Analytics}
     */

  }, {
    key: "screen",
    value: function screen(message, callback) {
      this._validate(message, "screen");
      this.enqueue("screen", message, callback);
      return this;
    }

    /**
     * Send an alias `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "alias",
    value: function alias(message, callback) {
      this._validate(message, "alias");
      this.enqueue("alias", message, callback);
      return this;
    }

    /**
     * Add a `message` of type `type` to the queue and
     * check whether it should be flushed.
     *
     * @param {String} type
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @api private
     */

  }, {
    key: "enqueue",
    value: function enqueue(type, message, callback) {
      callback = callback || noop;

      if (!this.enable) {
        return setImmediate(callback);
      }

      if (type == "identify") {
        if (message.traits) {
          if (!message.context) {
            message.context = {};
          }
          message.context.traits = message.traits;
        }
      }

      message = _extends({}, message);
      message.type = type;

      message.context = _extends({
        library: {
          name: "analytics-node",
          version: version
        }
      }, message.context);

      message._metadata = _extends({
        nodeVersion: process.versions.node
      }, message._metadata);

      if (!message.originalTimestamp) {
        message.originalTimestamp = new Date();
      }

      if (!message.messageId) {
        // We md5 the messaage to add more randomness. This is primarily meant
        // for use in the browser where the uuid package falls back to Math.random()
        // which is not a great source of randomness.
        // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).
        message.messageId = "node-" + md5(JSON.stringify(message)) + "-" + uuid();
      }

      // Historically this library has accepted strings and numbers as IDs.
      // However, our spec only allows strings. To avoid breaking compatibility,
      // we'll coerce these to strings if they aren't already.
      if (message.anonymousId && !isString(message.anonymousId)) {
        message.anonymousId = JSON.stringify(message.anonymousId);
      }
      if (message.userId && !isString(message.userId)) {
        message.userId = JSON.stringify(message.userId);
      }

      this.queue.push({ message: message, callback: callback });

      if (!this.flushed) {
        this.flushed = true;
        this.flush();
        return;
      }

      if (this.queue.length >= this.flushAt) {
        this.flush();
      }

      if (this.flushInterval && !this.timer) {
        this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
      }
    }

    /**
     * Flush the current queue
     *
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "flush",
    value: function flush(callback) {
      callback = callback || noop;

      if (!this.enable) {
        return setImmediate(callback);
      }

      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }

      if (!this.queue.length) {
        return setImmediate(callback);
      }

      var items = this.queue.splice(0, this.flushAt);
      var callbacks = items.map(function (item) {
        return item.callback;
      });
      var messages = items.map(function (item) {
        // if someone mangles directly with queue
        if (_typeof(item.message) == "object") {
          item.message.sentAt = new Date();
        }
        return item.message;
      });

      var data = {
        batch: messages,
        sentAt: new Date()
      };

      // console.log("===data===", data);

      var done = function done(err) {
        callbacks.forEach(function (callback_) {
          callback_(err);
        });
        callback(err, data);
      };

      // Don't set the user agent if we're not on a browser. The latest spec allows
      // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers
      // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),
      // but browsers such as Chrome and Safari have not caught up.
      var headers = {};
      if (typeof window === "undefined") {
        headers["user-agent"] = "analytics-node/" + version;
      }

      var req = {
        method: "POST",
        url: "" + this.host,
        auth: {
          username: this.writeKey
        },
        data: data,
        headers: headers
      };

      if (this.timeout) {
        req.timeout = typeof this.timeout === "string" ? ms(this.timeout) : this.timeout;
      }

      // console.log("===making axios request===");

      axios(req).then(function (response) {
        // handle success
        // console.log("===success===", response);
        done();
      }).catch(function (err) {
        // console.log("===err===", err);
        if (err.response) {
          var error = new Error(err.response.statusText);
          return done(error);
        }

        done(err);
      });
    }
  }, {
    key: "_isErrorRetryable",
    value: function _isErrorRetryable(error) {
      // Retry Network Errors.
      if (axiosRetry.isNetworkError(error)) {
        return true;
      }

      if (!error.response) {
        // Cannot determine if the request can be retried
        return false;
      }

      // Retry Server Errors (5xx).
      if (error.response.status >= 500 && error.response.status <= 599) {
        return true;
      }

      // Retry if rate limited.
      if (error.response.status === 429) {
        return true;
      }

      return false;
    }
  }]);

  return Analytics;
}();

module.exports = Analytics;